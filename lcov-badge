#!/usr/bin/env node
const fs = require('fs');
const ArgumentParser = require('argparse').ArgumentParser;
const parse = require('lcov-parse');
const { basic: badge, basicColors } = require('badge-up2');
const sharp = require('sharp');
const pkg = require('./package.json');

const defaultOutput = './badge.svg';
const defaultLabel = 'coverage';

const parser = new ArgumentParser({
	add_help: true,
});
parser.add_argument(
	'-v', '--version',
	{
		help: "Show program's version number and exit",
		action: 'version',
		version: pkg.version,
	}
);
parser.add_argument(
	'input',
	{
		help: 'Path to Lcov file to parse',
	}
);
parser.add_argument(
	'-o', '--output',
	{
		help: `Output file path (.svg or .png) (default: ${defaultOutput})`,
		default: defaultOutput,
	}
);
parser.add_argument(
	'-l', '--label',
	{
		help: `Badge label (default: ${defaultLabel})`,
		default: defaultLabel,
	}
);
const args = parser.parse_args();

const format = args.output.slice(-3);
if (format !== 'svg' && format !== 'png') {
	parser.printHelp();
	return;
}

parse(args.input, (parseErr, data) => {
	if (parseErr) {
		throw parseErr;
	}

	const summary = {
		lines: { found: 0, hit: 0 },
		branches: { found: 0, hit: 0 },
		functions: { found: 0, hit: 0 },
	};
	const keys = ['lines', 'branches', 'functions'];

	data.forEach((arg) => {
		keys.forEach((key) => {
			summary[key].found += arg[key].found;
			summary[key].hit += arg[key].hit;
		});
	});

	const average = Math.round(keys.reduce((avg, key) => {
		const found = summary[key].found;
		return avg + (found > 0
			? summary[key].hit / found * 100
			: 100);
	}, 0) / keys.length * 100) / 100;

	let color = 'red';
	if (average <= 85) {
		color = 'orange';
	} else if (average <= 90) {
		color = 'yellow';
	} else if (average <= 93) {
		color = 'yellowgreen';
	} else if (average <= 97) {
		color = 'green';
	} else {
		color = 'brightgreen';
	}

	let output = badge(args.label, `${average}%`, basicColors[color]);

	if (format === 'png') {
		const [, width] = output.match(/width="(\d+)"/i);
		const [, height] = output.match(/height="(\d+)"/i);
		sharp(Buffer.from(output))
			.resize(parseInt(width, 10), parseInt(height, 10))
			.toFile(args.output);
		return;
	}

	fs.writeFile(args.output, output, (writeErr) => {
		if (writeErr) {
			throw writeErr;
		}
	});
});
